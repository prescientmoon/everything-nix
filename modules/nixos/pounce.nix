# Taken from https://git.tempest.dev/ashe/nixos-wrapper-pounce/src/branch/main/flake.nix
# I have removed a lot of the things I didn't need, and modified a few things to fit 
# my preferences (specifically, simplified the cert situation)
{ config, lib, pkgs, ... }:
with lib;
let
  cfg = config.services.pounce;
  pkg = pkgs.pounce;
  defaultUser = "pounce";

  # {{{ systemd hardening flags
  hardeningFlags = {
    CapabilityBoundingSet = [ "" ];
    NoNewPrivileges = true;
    PrivateDevices = true;
    PrivateMounts = true;
    PrivateTmp = true;
    PrivateUsers = true;
    ProtectClock = true;
    ProtectControlGroups = true;
    ProtectKernelLogs = true;
    ProtectKernelModules = true;
    ProtectKernelTunables = true;
    ProtectProc = "invisible";
    RestrictAddressFamilies = [ "AF_INET" "AF_INET6" "AF_UNIX" ];
    RestrictNamespaces = true;
    RestrictSUIDSGID = true;
    SystemCallArchitectures = "native";
    SystemCallFilter = [ "@system-service" "~@privileged" "~@resources" ];
  };
  # }}}
in
{
  # {{{ Options
  options.services.pounce = {
    # {{{ general options
    enable = mkEnableOption "the Pounce IRC bouncer and Calico dispatcher";

    user = mkOption {
      type = types.str;
      default = defaultUser;
      description = lib.mdDoc ''
        User account under which Pounce runs. If not specified, a default user
        will be created.
      '';
    };

    dataDir = mkOption {
      type = types.str;
      default = "/run/pounce";
      description = lib.mdDoc ''
        Directory where each Pounce instance's UNIX-domain socket is stored for
        Calico to route to.
      '';
    };

    externalHost = mkOption {
      type = types.str;
      example = "example.org";
      description = lib.mdDoc ''
        Base domain name Calico will be accessible at. Each instance
        will be at a subdomain of this.
      '';
    };

    bindHost = mkOption {
      type = types.str;
      default = "localhost";
      description = lib.mdDoc ''
        The IP or host for Calico to bind to.
      '';
    };

    port = mkOption {
      type = types.port;
      default = 6697;
      description = lib.mdDoc "Port for Calico to listen on.";
    };

    openFirewall = mkOption {
      type = types.bool;
      default = false;
      description = lib.mdDoc "Open port in the firewall for Calico.";
    };

    timeout = mkOption {
      type = types.ints.positive;
      default = 1000;
      description = lib.mdDoc ''
        Timeout parameter (in milliseconds) for Calico to close a connection
        if no `ClientHello` message is sent.
      '';
    };

    certDir = mkOption {
      type = types.str;
      example = "/var/lib/acme/wildcard-irc.exmaple.com";
      description = lib.mdDoc ''
        Directory where each Pounce instance's TLS certificates and private
        keys are stored. The folder must contain wildcard certs as generated by acme.
      '';
    };
    # }}} 
    # {{{ networks 
    networks = mkOption {
      type = types.attrsOf (types.submodule {
        options = {
          config = mkOption {
            type = types.path;
            description = lib.mdDoc ''
              Location to load pounce configuration from
            '';
          };
        };
      });
      default = { };
      description = lib.mdDoc "Attribute set of IRC networks to connect to.";
    };
  };
  # }}}
  # }}}
  # {{{ config 
  config = mkIf cfg.enable {
    systemd.tmpfiles.rules = [ "d ${cfg.dataDir} 0700 ${cfg.user} ${cfg.user} -" ];
    systemd.services = mkMerge (
      # {{{ calico service 
      [
        {
          calico = {
            wantedBy = [ "multi-user.target" ];
            after = [ "network.target" ];

            description = "Calico dispatcher for Pounce IRC bouncer.";

            serviceConfig = {
              User = cfg.user;
              Group = cfg.user;
              ExecStart = ''
                ${pkg}/bin/calico \
                  -H ${cfg.bindHost} -P ${toString cfg.port} \
                  -t ${toString cfg.timeout} ${cfg.dataDir}
              '';
              Restart = "on-failure";
            } // hardeningFlags;
          };
        }
      ] ++
      # }}}
      # {{{ pounce service
      (mapAttrsToList
        (name: value: mkMerge [
          {
            "pounce-${name}" = {
              wantedBy = [ "calico.service" ];
              after = [ "network.target" ];
              before = [ "calico.service" ];

              description = "Pounce IRC bouncer for the ${name} network.";

              serviceConfig = {
                User = cfg.user;
                Group = cfg.user;
                ExecStart = ''
                  ${pkg}/bin/pounce \
                    -C ${cfg.certDir}/fullchain.pem \
                    -K ${cfg.certDir}/key.pem \
                    -U ${cfg.dataDir} -H ${name}.${cfg.externalHost} \
                    ${value.config}
                '';
                Restart = "on-failure";
              } // hardeningFlags;
            };
          }
        ])
        cfg.networks)
      # }}}
    );

    users = optionalAttrs (cfg.user == defaultUser) {
      users.${defaultUser} = {
        group = defaultUser;
        isSystemUser = true;
      };

      groups.${defaultUser} = { };
    };

    networking.firewall.allowedTCPPorts = mkIf cfg.openFirewall [ cfg.port ];
  };
  # }}}
}
